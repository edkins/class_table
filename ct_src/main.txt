class split_str {
    head : lexeme,
    specificity : u32,
    tail : str,
}

class lexeme {}

class keyword : lexeme {
    fn parse(Self, input: str) -> sequence[split_str] {
        if startswith(input, Self.name) {
            yield split_str {
                head: Self {},
                specificity: 1,
                tail: from(input, len(Self.name)),
            };
        }
    }
}

fn better(x: split_str, y: split_str) -> bool {
    if len(x.tail) < len(y.tail) {
        true
    } else if len(x.tail) > len(y.tail) {
        false
    } else {
        x.specificity > y.specificity
    }
}

fn parse_lexemes(input: str) -> optional[split_str] {
    let mut best = null;
    let mut suggestion = null;
    for k : implementors(lexeme, "parse") {
        for suggestion : k.parse(input) {
            if best == null || better(suggestion, best) {
                best = suggestion;
            }
        }
    }
    best
}

class 'class' : keyword {}

class identifier : lexeme {
    name: str

    fn parse(Self, input: str) -> sequence[split_str] {
        let mut result = null;
        let name = "";
        for ch : input {
            if is_alphanum(ch) || ch == "_" {
                name += ch;
                yield split_str {
                    head: Self { name: name },
                    specificity: 0,
                    tail: from(input, len(name)),
                };
            } else {
                break;
            }
        }
    }
}

fn main(input: str) -> str {
    let mut result = "unable to parse";
    let s = parse_lexemes(input);
    if s != null {
        result = s.head;
    }
    result
}