class split_str {
    head : str,
    specificity : u32,
    tail : str,
}

class keyword : metaclass {
    name : token : header,
    metaclass : metaclass : header,
    classes : list[keyword] : builtin,
}

fn parse_keyword(k : keyword, input: str) -> optional[split_str] {
    let mut result = null;
    if startswith(input, k.name) {
        result = split_str {
            head: k.name,
            specificity: 1,
            tail: from(input, len(k.name)),
        };
    }
    result
}

fn better(x: split_str, y: split_str) -> bool {
    if len(x.tail) < len(y.tail) {
        true
    } else if len(x.tail) > len(y.tail) {
        false
    } else {
        x.specificity > y.specificity
    }
}

fn parse_keywords(input: str) -> optional[split_str] {
    let mut best = null;
    let mut suggestion = null;
    for k : keyword.classes {
        suggestion = parse_keyword(k, input);
        if suggestion != null {
            if best == null || better(suggestion, best) {
                best = suggestion;
            }
        }
    }
    best
}

class 'class' : keyword {}
class 'classification' : keyword {}

fn main(input: str) -> str {
    let mut result = "unable to parse";
    let s = parse_keywords(input);
    if s != null {
        result = s.head;
    }
    result
}